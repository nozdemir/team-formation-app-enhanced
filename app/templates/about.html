{% extends "base.html" %}

{% block content %}
<div class="row">
    <div class="col-lg-8">
        <h1>About Team Formation System</h1>
        <p>This system uses advanced graph algorithms to form optimal research teams based on expertise and collaboration networks.</p>
        
        <h3>Available Algorithms</h3>
        <div class="row">
            <div class="col-md-6">
                <h5>ACET</h5>
                <p>All-Connections-Equal Team Formation</p>
                
                <h5>CAT</h5>
                <p>Co-Authorship Team Formation</p>
                
                <h5>OAT</h5>
                <p>Organizational Affiliation Team Formation</p>
                
                <h5>PRT</h5>
                <p>Prioritized Relationship Team Formation</p>
            </div>
            <div class="col-md-6">
                <h5>COT</h5>
                <p>Cohesion-Optimized Team Formation</p>
                
                <h5>TAT</h5>
                <p>Time-Aware Team Formation</p>
                
                <h5>CIT</h5>
                <p>Citation-Optimized Team Formation</p>
            </div>
        </div>
        
        <h3>How It Works</h3>
        <ol>
            <li>Select keywords representing required expertise areas</li>
            <li>Choose a team formation algorithm</li>
            <li>System finds authors with matching skills</li>
            <li>Forms teams based on collaboration networks</li>
        </ol>
    </div>
</div>
{% endblock %}

from neo4j import GraphDatabase
import logging
import random
from typing import List, Dict, Tuple, Optional

logger = logging.getLogger(__name__)

class TeamBuilder:
    """Main class for team formation using Neo4j database"""
    
    def __init__(self):
        """Initialize Neo4j connection"""
        self.driver = None
        self.connect_to_neo4j()
    
    def connect_to_neo4j(self):
        """Connect to Neo4j database using environment variables"""
        import os
        
        try:
            neo4j_url = os.getenv('NEO4J_URI', 'bolt://localhost:7687')
            neo4j_user = os.getenv('NEO4J_USER', 'neo4j')
            neo4j_password = os.getenv('NEO4J_PASSWORD', 'password')
            
            logger.info(f"Connecting to Neo4j at: {neo4j_url}")
            
            self.driver = GraphDatabase.driver(
                neo4j_url, 
                auth=(neo4j_user, neo4j_password),
                encrypted=False
            )
            
            # Test connection
            with self.driver.session() as session:
                result = session.run("RETURN 1 as test")
                test_value = result.single()["test"]
                if test_value == 1:
                    logger.info("Successfully connected to Neo4j")
                else:
                    raise Exception("Connection test failed")
                    
        except Exception as e:
            logger.error(f"Failed to connect to Neo4j: {e}")
            # Don't raise exception here to allow app to start
            self.driver = None
    
    def test_connection(self) -> Tuple[bool, str]:
        """Test Neo4j database connection"""
        if not self.driver:
            return False, "No database connection established"
        
        try:
            with self.driver.session() as session:
                result = session.run("RETURN 'Connection successful' as message")
                message = result.single()["message"]
                return True, message
        except Exception as e:
            logger.error(f"Connection test failed: {e}")
            return False, f"Connection failed: {str(e)}"
    
    def get_database_stats(self) -> Dict:
        """Get basic database statistics"""
        if not self.driver:
            return {"error": "No database connection"}
        
        try:
            with self.driver.session() as session:
                # Get node counts
                node_query = """
                MATCH (n)
                RETURN labels(n)[0] as label, count(n) as count
                ORDER BY count DESC
                """
                node_result = session.run(node_query)
                nodes = {record["label"]: record["count"] for record in node_result}
                
                # Get relationship counts
                rel_query = """
                MATCH ()-[r]->()
                RETURN type(r) as rel_type, count(r) as count
                ORDER BY count DESC
                """
                rel_result = session.run(rel_query)
                relationships = {record["rel_type"]: record["count"] for record in rel_result}
                
                return {
                    "nodes": nodes,
                    "relationships": relationships
                }
        except Exception as e:
            logger.error(f"Error getting database stats: {e}")
            return {"error": str(e)}
    
    def get_available_keywords(self) -> List[str]:
        """Get list of available keywords from the database"""
        if not self.driver:
            return ["machine learning", "data science", "algorithms", "databases"]  # Default keywords
        
        try:
            with self.driver.session() as session:
                query = """
                MATCH (k:Keyword)
                RETURN k.name as keyword
                ORDER BY keyword
                LIMIT 50
                """
                result = session.run(query)
                keywords = [record["keyword"] for record in result if record["keyword"]]
                
                if not keywords:
                    # Fallback keywords if none found in database
                    keywords = [
                        "machine learning", "data science", "algorithms", "databases",
                        "artificial intelligence", "software engineering", "web development",
                        "mobile development", "cybersecurity", "cloud computing"
                    ]
                
                return keywords
        except Exception as e:
            logger.error(f"Error getting keywords: {e}")
            return ["machine learning", "data science", "algorithms", "databases"]
    
    def find_authors_by_keywords(self, keywords: List[str], limit: int = 50) -> List[Dict]:
        """Find authors based on keywords"""
        if not self.driver:
            return []
        
        try:
            with self.driver.session() as session:
                query = """
                MATCH (a:Author)-[:HAS_EXPERTISE]->(k:Keyword)
                WHERE toLower(k.name) IN $keywords
                WITH a, collect(k.name) as expertise
                RETURN a.name as name, a.id as id, expertise
                LIMIT $limit
                """
                
                result = session.run(query, keywords=[kw.lower() for kw in keywords], limit=limit)
                authors = []
                
                for record in result:
                    authors.append({
                        "id": record["id"],
                        "name": record["name"],
                        "expertise": record["expertise"]
                    })
                
                return authors
        except Exception as e:
            logger.error(f"Error finding authors: {e}")
            return []
    
    def get_collaboration_network(self, author_ids: List[str]) -> Dict:
        """Get collaboration relationships between authors"""
        if not self.driver or not author_ids:
            return {}
        
        try:
            with self.driver.session() as session:
                query = """
                MATCH (a1:Author)-[r:COLLABORATED_WITH]->(a2:Author)
                WHERE a1.id IN $author_ids AND a2.id IN $author_ids
                RETURN a1.id as source, a2.id as target, r.weight as weight
                """
                
                result = session.run(query, author_ids=author_ids)
                collaborations = {}
                
                for record in result:
                    source = record["source"]
                    target = record["target"]
                    weight = record["weight"] or 1
                    
                    if source not in collaborations:
                        collaborations[source] = {}
                    collaborations[source][target] = weight
                
                return collaborations
        except Exception as e:
            logger.error(f"Error getting collaborations: {e}")
            return {}
    
    def build_simple_teams(self, keywords: List[str], algorithm: str = "ACET", max_teams: int = 3) -> Tuple[List[Dict], str]:
        """Build teams using simple algorithm"""
        try:
            # Find authors with relevant expertise
            authors = self.find_authors_by_keywords(keywords, limit=30)
            
            if not authors:
                return [], "No authors found with the specified expertise"
            
            if len(authors) < 3:
                return [], f"Only {len(authors)} author(s) found. Need at least 3 for team formation"
            
            # Get collaboration network
            author_ids = [author["id"] for author in authors]
            collaborations = self.get_collaboration_network(author_ids)
            
            # Simple team formation - distribute authors across teams
            teams = []
            authors_copy = authors.copy()
            random.shuffle(authors_copy)
            
            team_size = max(3, len(authors) // max_teams)
            
            for i in range(max_teams):
                if not authors_copy:
                    break
                
                team_authors = []
                for j in range(min(team_size, len(authors_copy))):
                    if authors_copy:
                        team_authors.append(authors_copy.pop())
                
                if len(team_authors) >= 2:  # Only create teams with at least 2 members
                    team = {
                        "id": i + 1,
                        "members": team_authors,
                        "algorithm": algorithm,
                        "expertise_coverage": list(set([exp for member in team_authors for exp in member["expertise"]])),
                        "team_size": len(team_authors)
                    }
                    teams.append(team)
            
            status_message = f"Used {algorithm} algorithm with {len(keywords)} keyword(s)"
            return teams, status_message
            
        except Exception as e:
            logger.error(f"Error building teams: {e}")
            return [], f"Error building teams: {str(e)}"
    
    def close(self):
        """Close Neo4j connection"""
        if self.driver:
            self.driver.close()
            logger.info("Neo4j connection closed")
    
    def __del__(self):
        """Cleanup on object destruction"""
        self.close()


# Simple data classes for team formation results
class Team:
    """Represents a formed team"""
    def __init__(self, team_id: int, members: List[Dict], algorithm: str):
        self.id = team_id
        self.members = members
        self.algorithm = algorithm
        self.size = len(members)
        self.expertise = self._get_combined_expertise()
    
    def _get_combined_expertise(self) -> List[str]:
        """Get combined expertise of all team members"""
        expertise = set()
        for member in self.members:
            if "expertise" in member:
                expertise.update(member["expertise"])
        return list(expertise)
    
    def to_dict(self) -> Dict:
        """Convert team to dictionary"""
        return {
            "id": self.id,
            "members": self.members,
            "algorithm": self.algorithm,
            "size": self.size,
            "expertise": self.expertise
        }


class Author:
    """Represents an author/researcher"""
    def __init__(self, author_id: str, name: str, expertise: List[str] = None):
        self.id = author_id
        self.name = name
        self.expertise = expertise or []
        self.collaborations = {}
    
    def add_collaboration(self, other_id: str, weight: float = 1.0):
        """Add a collaboration relationship"""
        self.collaborations[other_id] = weight
    
    def to_dict(self) -> Dict:
        """Convert author to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "expertise": self.expertise,
            "collaborations": self.collaborations
        }